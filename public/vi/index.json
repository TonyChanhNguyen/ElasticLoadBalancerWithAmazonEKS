[
{
	"uri": "/vi/4-ingresswitheks/4.1-installlbc/",
	"title": "Cài đặt AWS Load Balancer Controller",
	"tags": [],
	"description": "",
	"content": "AWS Load Balancer Controller là một bộ điều khiển giúp quản lý Elastic Load Balancers cho một Kubernetes cluster. Bộ điều khiển có thể cung cấp các tài nguyên dưới đây:\n Một AWS Application Load Balancer khi bạn tạo Kubernetes Ingress. Một AWS Network Load Balancer hoặc Classic Load Balancer khi bạn tạo một Kubernetes Service với Type là LoadBalancer.  Để tích hợp Application Pod trên EC2 Managed Nodegroup với Ingress (Application Load Balanber) và Route53. Các quyền truy cập alb-ingress-access, full-ecr-access và external-dns-access là cần thiết. Để thực hiện điều đó, chúng ta sẽ xóa Nodegroup hiện tại và tạo lại cái mới với các quyền đó.\nXóa NodeGroup hiện tại 1.Thực thi câu lệnh bên dưới để xóa EC2 Managed NodeGroup hiện tại.\neksctl delete nodegroup --cluster fcj-elb-cluster --region ap-southeast-1 --name fcj-elb-nodegroup --disable-eviction  Sẽ mất khoảng 5 phút để hoàn tất.   Liệt kê lại tất cả các Node bên trong Cluster để đảm bảo nó đã xóa.\n  kubectl get nodes Tạo một NodeGroup mới. 1.Thực thi câu lệnh bên dưới để tạo mọt EC2 Managed NodeGroup mới với quyền truy cập alb-ingress-access, full-ecr-access và external-dns-access.\neksctl create nodegroup --cluster fcj-elb-cluster --region ap-southeast-1 --name fcj-ingress-nodegroup --managed --nodes=1 --node-type=t3.large --alb-ingress-access --full-ecr-access --external-dns-access --node-private-networking  Sẽ mất khoảng 5 phút để hoàn tất.   Liệt kê Node đã tạo.\n  kubectl get nodes -o wide Tạo IAM Policy Ở bước này, chúng ta sẽ tạo IAM Policy cho AWS Load Balancer Controller để cho phép nó thực hiện gọi đến AWS API thay bạn.\n Tại cửa sổ lệnh Cloud9, tải xuống IAM Policy.  curl -o iam_policy_latest.json https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/main/docs/install/iam_policy.json Tạo IAM Policy sử dụng policy vừa tải xuống.  aws iam create-policy --policy-name AWSLoadBalancerControllerIAMPolicy --policy-document file://iam_policy_latest.json Lưu lại Policy ARN vì chúng ta sẽ sử dụng khi tạo IAM Role.  Tạo một IAM Role cho AWS LoadBalancer Controller và gán Role cho Kubernetes Service Account.  Kiểm tra xem Service Account có tồn tại.  kubectl get sa aws-load-balancer-controller -n kube-system Không có Service Account được tạo tên là aws-load-balancer-controller trong Namespace kube-system ở Cluster.\nTạo IAM Role. Thay thế với Policy ARN.  eksctl create iamserviceaccount \\\r--cluster=fcj-elb-cluster \\\r--region=ap-southeast-1 \\\r--namespace=kube-system \\\r--name=aws-load-balancer-controller \\\r--attach-policy-arn=\u0026lt;REPACE-WITH-YOUR-POLICY-ARN\u0026gt; \\\r--override-existing-serviceaccounts \\\r--approve Kiểm tra có một Service Account tên aws-load-balancer-controller trong Namespace kube-system ở Cluster.  Khám phá chi tiết Service Account.  kubectl describe sa aws-load-balancer-controller -n kube-system  Tại mục Annotations, có thể thấy có một IAM Role Arn liên kết tới Service Account. Sao chép tên IAM Role.   Truy cập IAM Role và tìm kiếm với tên IAM Role để kiểm tra kết quả.   Có một IAM Role được tạo và kết nối với Service Account tự động khi bạn tạo nó.\nCài đặt AWS Load Balancer Controller Ở bước này, chúng ta sẽ cài đặt AWS Load Balancer Controller bằng Helm.\n Cài đặt Helm.  curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 \u0026gt; get_helm.sh\rchmod 700 get_helm.sh\r./get_helm.sh Kiểm tra phiên bản Helm.  helm version Cài đặt AWS Load Balancer Controller với Helm. Thay thế với VPC ID của Cluster.  # Add the eks-charts repository.\rhelm repo add eks https://aws.github.io/eks-charts\r# Update your local repo to make sure that you have the most recent charts.\rhelm repo update\r# Install the AWS Load Balancer Controller.\rhelm install aws-load-balancer-controller eks/aws-load-balancer-controller \\\r-n kube-system \\\r--set clusterName=fcj-elb-cluster \\\r--set serviceAccount.create=false \\\r--set serviceAccount.name=aws-load-balancer-controller \\\r--set region=ap-southeast-1 \\\r--set vpcId=\u0026lt;REPLACE-WITH-CLUSTER-VPC-ID\u0026gt; \\\r--set image.repository=602401143452.dkr.ecr.ap-southeast-1.amazonaws.com/amazon/aws-load-balancer-controller Kiểm tra bộ điều khiển đã được cài đặt và Webhook Service đã được tạo.  kubectl -n kube-system get deployment aws-load-balancer-controller\rkubectl -n kube-system get svc aws-load-balancer-webhook-service\rkubectl get pods -n kube-system Các tài nguyên được tạo ra:\n Một Deployment tên aws-load-balancer-controller. Một Webhook Service tên aws-load-balancer-webhook-service. Hai Pods tên aws-load-balancer-controller-xxxxxxxxxx-xxxxx.  Hãy khám phá Pod để tạo để thấy rằng thông số AWS_ROLE_ARN là IAM Role ARN đã được tạo ra khi bạn tạo Service Account.  Bạn đã cài đặt AWS Load Balancer Controller thành công.\nTạo Ingress Class  Tạo một thư mục làm việc mới cho phần này.  cd ~\rcd environment\rmkdir ingress Tạo một thư mục mới để chứa tệp manifest Ingress class.  mkdir ingress/ingress-class\rls ingress Tạo một tệp manifest tên ingress-class.yaml bên trong ingress/ingress-class.  touch ingress/ingress-class/ingress-class.yaml\rls ingress/ingress-class/ 4.Mở tệp ingress-class.yaml, dán đoạn code bên dưới. Sau đó lưu lại.\napiVersion: networking.k8s.io/v1\rkind: IngressClass\rmetadata:\rname: my-aws-ingress-class\rannotations:\ringressclass.kubernetes.io/is-default-class: \u0026#34;true\u0026#34;\rspec:\rcontroller: ingress.k8s.aws/alb Thực thi câu lệnh bên dưới để tạo Ingress Class.  kubectl apply -f ingress/ingress-class Liệt kê Ingress Class được tạo.  kubectl get ingressclass Có một Ingress Class được tạo tên my-aws-ingress-class.\nKhám phá Ingress Class được tạo.  kubectl describe ingressclass my-aws-ingress-class "
},
{
	"uri": "/vi/3-clbnlbwitheks/3.1-clbnlbwitheksmangednode/",
	"title": "Dịch vụ Classic Load Balancer với Amazon EKS Cluster EC2 Managed NodeGroup",
	"tags": [],
	"description": "",
	"content": "Tạo các tệp Manifest  Tạo một thư mục cho phần CLB.  cd ..\rmkdir clb\rcd clb Tạo một tệp tên app-deployment.yaml bên trong clb.  touch app-deployment.yaml Mở tệp app-deployment.yaml, dán đoạn mã code bên dưới. Sau đó lưu lại. Đừng quên thay thế \u0026lt;REPLACE-WITH-YOUR-CONTAINER-IMAGE-URL\u0026gt; với container image URL của bạn trên DockerHub.  apiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: fcj-app1-deployment\rlabels:\rapp: fcj-app1\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: fcj-app1\rtemplate:\rmetadata:\rlabels:\rapp: fcj-app1\rspec:\rcontainers:\r- name: fcj-app1\rimage: \u0026lt;REPLACE-WITH-YOUR-CONTAINER-IMAGE-URL\u0026gt;\rports:\r- containerPort: 80 Ở trường hợp này, container image URL trên DockerHub là firstcloudjourneypcr/fcj-elbeks-workshop-basicapp:v1. Bạn có thể thay thế bằng nó cho mục đích kiểm thử.\nTạo tệp ClassicLoadBalancer.yaml bên trong clb.  touch ClassicLoadBalancer.yaml Mở tệp ClassicLoadBalancer.yaml, dán đoạn mã code bên dưới. Sau đó lưu lại.  apiVersion: v1\rkind: Service\rmetadata:\rname: fcj-app1-clb-svc\rlabels: app: fcj-app1\rspec:\rtype: LoadBalancer # Default - CLB\rselector:\rapp: fcj-app1\rports: - port: 8080\rtargetPort: 8080 Triển khai tài nguyên  Tạo một namespace để triển khai tài nguyên.  kubectl create ns fcj-app1\rkubectl get ns Thực thi câu lệnh bên dưới để triển khai tài nguyên lên namespace fcj-app1.  kubectl apply -n fcj-app1 -f . Liệt kê tất cả tài nguyên đã tạo trên namespace fcj-app1.  kubectl get deploy,pod,svc -n fcj-app1 Các tài nguyên được tạo ở namespace fcj-app1:\n Một Deployment tên fcj-app1-deployment. Một Pod tên fcj-app1-deployment-7d9d4f7c44-ddvj8 với STATUS là Running. Một Service tên fcj-app1-clb-svc với TYPE là LoadBalancer và EXTERNAL-IP là a89ef47f06ea949c2b6e6e91bafc6545-898842507.ap-southeast-1.elb.amazonaws.com.   Hãy truy cập Load Balancer. Có một Load Balancer được tạo với Type là classic và DNS name khớp với EXTERNAL-IP của fcj-app1-clb-svc Service.   Hãy truy cập đường dẫn http://\u0026lt;YOUR-EXTERNAL-IP\u0026gt;:8080 để kiểm tra kết quả.   Ứng dụng của bạn đã được triển khai lên Classic Load Balancer thành công.\nDọn dẹp.  Thực thi câu lệnh bên dưới để xóa các tài nguyên đã tạo.  kubectl delete -n fcj-app1 -f . Liệt kê tất cả tài nguyên để đảm bảo rằng chúng đã được xóa.  kubectl get deploy,pod,svc -n fcj-app1 Xóa Namespace đã tạo.  kubectl delete ns fcj-app1 Liệt kê tất cả namespace để đảm bảo rằng nó đã được xóa.  kubectl get ns Truy cập Load Balancer để xác minh Classic Load Balancer vừa tạo đã tự động được xóa khi fcj-app1-clb-svc Service bị xóa.   "
},
{
	"uri": "/vi/6-nlbwitheks/6.1-nlbwitheksmanagednode/",
	"title": "Dịch vụ Network Load Balancer với Amazon EKS Cluster EC2 Managed Node",
	"tags": [],
	"description": "",
	"content": "Triển khai dịch vụ Network Load Balancer cơ bản với Amazon EKS Cluster EC2 Managed Node Tạo tệp Manifest.  Tạo thư mục làm việc mới cho phần này.  mkdir nlb\rls Tạo thư mục mới.  mkdir nlb/ManagedNodeGroup\rls nlb Sao chép tệp manifest tên app-deployment.yaml từ clb/ManagedNodeGroup/ đến nlb/ManagedNodeGroup.  cp clb/ManagedNodeGroup/app-deployment.yaml nlb/ManagedNodeGroup\rls nlb/ManagedNodeGroup Tạo tệp tên NetworkLoadBalancer.yaml bên trong nlb/ManagedNodeGroup.  touch nlb/ManagedNodeGroup/NetworkLoadBalancer.yaml\rls nlb/ManagedNodeGroup Mở tệp NetworkLoadBalancer.yaml, dán đoạn code bên dưới và lưu lại.  apiVersion: v1\rkind: Service\rmetadata:\rname: fcj-basic-nlb-service\rannotations:\r# Traffic Routing\rservice.beta.kubernetes.io/aws-load-balancer-name: fcj-basic-nlb\rservice.beta.kubernetes.io/aws-load-balancer-type: external\r# Health Check Settings\rservice.beta.kubernetes.io/aws-load-balancer-healthcheck-protocol: http\rservice.beta.kubernetes.io/aws-load-balancer-healthcheck-port: traffic-port\rservice.beta.kubernetes.io/aws-load-balancer-healthcheck-path: /\rservice.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold: \u0026#34;3\u0026#34;\rservice.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold: \u0026#34;3\u0026#34;\rservice.beta.kubernetes.io/aws-load-balancer-healthcheck-interval: \u0026#34;10\u0026#34; # Access Control\rservice.beta.kubernetes.io/load-balancer-source-ranges: 0.0.0.0/0 service.beta.kubernetes.io/aws-load-balancer-scheme: \u0026#34;internet-facing\u0026#34;\rspec:\rtype: LoadBalancer\rselector:\rapp: fcj-app1\rports:\r- port: 80\rtargetPort: 80 Triển khai tài nguyên.  Thực thi câu lệnh bên dưới để triển khai tài nguyên trên Namespace fcj-external-dns-ingress-ns.  kubectl apply -f nlb/ManagedNodeGroup -n fcj-external-dns-ingress-ns\rkubectl get all -n fcj-external-dns-ingress-ns Các tài nguyên được tạo:\n Một Deployment tên fcj-app1-deployment với replicas là 1. Một ReplicaSet tên fcj-app1-deployment-xxxxxxxxxx với replicas là 1. Một Pod tên fcj-app1-deployment-xxxxxxxxxx-xxxxx với STATUS là Running. Một Service tên fcj-basic-nlb-service với Type là LoadBalancer và EXTERNAL-IP là fcj-basic-nlb-b85e5b7a2c14c0d3.elb.ap-southeast-1.amazonaws.com.   Hãy truy cập Load Balancer. Có một Load Balancer được tạo với Type là network và DNS name khớp với EXTERNAL-IP của fcj-basic-nlb-service Service.   Nhấn vào Load Balancer để xác minh Listeners. Khi truy cập vào ứng dụng thông qua TCP:8080, nó sẽ được chuyển hướng đến TargetGroup được tạo.   Nhấn vào TargetGroup được tạo để xác minh Registered targets.   Registered targets là EC2 Managed Node trong Cluster với Health status là Healthy.\nKiểm tra kết quả.  Truy cập vào URL ứng dụng http://\u0026lt;YOUR-NETWORK-LOAD-BALANCER-URL\u0026gt;:8080.   (Tùy chọn) Tích hợp với dịch vụ ExternalDNS. Chỉnh sửa tệp Manifest.  Mở tệp NetworkLoadBalancer.yaml, thêm đoạn chú thích bên dưới để tích hợp với dịch vụ ExternalDNS. Sau đó lưu lại.  # External DNS - For creating a Record Set in Route53\rexternal-dns.alpha.kubernetes.io/hostname: fcjnlb.\u0026lt;YOUR-DOMAIN-NAME\u0026gt; Triển khai tài nguyên.  Thực thi câu lệnh bên dưới để triển khai tài nguyên trên Namespace fcj-external-dns-ingress-ns.  kubectl apply -f nlb/ManagedNodeGroup -n fcj-external-dns-ingress-ns\rkubectl get all -n fcj-external-dns-ingress-ns Service tên fcj-basic-nlb-service sẽ được cấu hình.\nKiểm tra kết quả.  Truy cập http://fcjnlb.\u0026lt;YOUR-DOMAIN-NAME\u0026gt;:8080 để kiểm tra.  Dọn dẹp.  Xóa tài nguyên đã tạo.  kubectl delete -f nlb/ManagedNodeGroup -n fcj-external-dns-ingress-ns\rkubectl get all -n fcj-external-dns-ingress-ns Sẽ giữ lại các tài nguyên liên quan đến dịch vụ external-dns và SSL certificate trên AWS Certificate Manager cho các phần tiếp theo.\nTruy cập Load Balancer để xác minh rằng Network Load Balancer được tạo ra đã được tự động xóa khi Service fcj-basic-nlb-service bị xóa.   "
},
{
	"uri": "/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Tổng quan Classic Load Balancer cung cấp khả năng cân bằng tải đơn giản trên nhiều phiên bản Amazon EC2 và hoạt động tại cả cấp độ yêu cầu và cấp độ kết nối. Classic Load Balancer được thiết kế dành cho các ứng dụng được xây dụng với mạng EC2-Classic.\nApplication Load Balancer hoạt động ở cấp độ yêu cầu (lớp layer 7), điều hướng truy cập đến các mục tiêu (máy chủ EC2, container, địa chỉ IP, và Lambda) dựa trên nội dung của yêu cầu. Lý tưởng cho khả năng cân bằng tải nâng cao của các truy cập HTTP và HTTPS, Application Load Balancer cung cấp tính năng định tuyến yêu cầu nâng cao nhằm phân phối các kiến trúc ứng dụng hiện đại, bao gồm các ứng dụng microservice và container-based. Application Load Balancer đơn giản hóa và nâng cao khả năng bảo mật của ứng dụng, bằng việc đảm bảo rằng các giao thức và mật mã SSL/TLS mới nhất luôn được sử dụng.\nNetwork Load Balancer hoạt động ở cấp độ kết nối (lớp layer 4), điều hướng kết nối đến mục tiêu (máy chủ Amazon EC2, microservice và container) bên trong Amazon VPC, dựa vào dữ liệu phương thức IP. Lý tưởng cho khả năng cân bằng tải cho cả lưu lượng truy cập TCP và UDP, Network Load Balancer có khả năng xử lý hàng triệu yêu cầu mỗi giây trong khi vẫn duy trì độ trễ cực thấp. Network Load Balancer được tối ưu hóa để xử lý các dạng lưu lượng truy cập đột ngột và không ổn định trong khi vẫn sử dụng một địa chỉ IP tĩnh mỗi Availability Zone. Nó được tích hợp với các dịch vụ phổ biến khác của AWS như Auto Scaling, Amazon EC2 Container Service (ECS), Amazon CloudFormation, và AWS Certificate Manager (ACM).\nRoute 53 là một dịch vụ web Hệ thống tên miền (DNS) có tính sẵn sàng cao và có khả năng mở rộng. Route 53 kết nối yêu cầu của người dùng tới các ứng dụng internet chạy trên AWS hoặc tại chỗ (on-premise).\nAWS Certificate Manager giúp cung cấp, quản lý, và triển khai chứng chỉ SSL/TLS công khai và riêng tư để sử dụng với các dịch vụ của AWS và các tài nguyên được kết nối nội bộ. ACM loại bỏ các quy trình thủ công tốn thời gian như chi trả, tải lên, và làm mới các chứng chỉ SSL/TLS.\nNội dung  Giới thiệu Các bước chuẩn bị Dịch vụ Classic Load Balancer với Amazon EKS Cluster Dịch vụ Ingress với Amazon EKS Cluster (Tùy chọn) Tích hợp dịch vụ ExternalDNS cho Amazon EKS Cluster Dịch vụ Network Load Balancer với Amazon EKS Cluster Dọn dẹp tài nguyên  "
},
{
	"uri": "/vi/",
	"title": "Triển khai dịch vụ cân bằng tải trên Amazon EKS",
	"tags": [],
	"description": "",
	"content": "Triển khai dịch vụ cân bằng tải trên Amazon EKS Tổng quan This workshop will provide a high level overview on how to integrate Load Balancer Service for application that run on Amazon EKS Cluster with Class Load Balancer, Application Load Balancer (Ingress Service) and Network Load Balancer.\nBài thực hành này sẽ cung cấp một cái nhìn tổng quan về việc làm thế nào để tích hợp dịch vụ cân bằng tải cho ứng dụng chạy trên Amazon EKS Cluster với Class Load Balancer, Application Load Balancer (Ingress Service) và Network Load Balancer.\nHơn nữa, chúng ta sẽ tích hợp dịch vụ cân bằng tải với dịch vụ quản lý tên miền (DNS) thông qua Route 53 và bảo mật truy cập vào ứng dụng bằng AWS Certificate Manager.\nNội dung  Giới thiệu Các bước chuẩn bị Dịch vụ Classic Load Balancer với Amazon EKS Cluster Dịch vụ Ingress với Amazon EKS Cluster (Tùy chọn) Tích hợp dịch vụ ExternalDNS cho Amazon EKS Cluster Dịch vụ Network Load Balancer với Amazon EKS Cluster Dọn dẹp tài nguyên  "
},
{
	"uri": "/vi/5-dnsingresswitheks/5.1-deployexternaldns/",
	"title": "Triển khai ExternalDNS Service",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ triển khai ExternalDNS Service trên Amazon EKS Cluster.\nLấy cảm hứng từ Kubernetes DNS, máy chủ DNS nội bộ theo cụm của Kubernetes, InternalDNS giúp các tài nguyên Kubernetes có thể được khám phá thông qua các máy chủ DNS công cộng. Giống như KubeDNS, nó truy xuất danh sách tài nguyên (Dịch vụ, Truy cập, v.v.) từ API Kubernetes để xác định danh sách bản ghi DNS mong muốn. Tuy nhiên, không giống như KubeDNS, bản thân nó không phải là máy chủ DNS mà chỉ định cấu hình các nhà cung cấp DNS khác cho phù hợp—ví dụ: AWS Route53.\nTheo nghĩa rộng hơn, ExternalDNS cho phép bạn kiểm soát các bản ghi DNS một cách linh hoạt thông qua tài nguyên Kubernetes theo cách không phân biệt nhà cung cấp DNS.\n Tạo một thư mục làm việc cho phần này.  mkdir ingress/externaldns Tạo một thư mục mới để chứa các tệp Manifest cho việc triển khai ExternalDNS Service.  mkdir ingress/externaldns/externaldns-deployment Tạo Service Account. Tạo IAM Policy.  Đi đến IAM Policy. Nhấn Create policy.  2. Chuyển đến thanh JSON. 3. Dán đoạn code bên dưới vào Policy editor. 4. Nhấn Next.\n{\r\u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;,\r\u0026#34;Statement\u0026#34;: [\r{\r\u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;,\r\u0026#34;Action\u0026#34;: [\r\u0026#34;route53:ChangeResourceRecordSets\u0026#34;\r],\r\u0026#34;Resource\u0026#34;: [\r\u0026#34;arn:aws:route53:::hostedzone/*\u0026#34;\r]\r},\r{\r\u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;,\r\u0026#34;Action\u0026#34;: [\r\u0026#34;route53:ListHostedZones\u0026#34;,\r\u0026#34;route53:ListResourceRecordSets\u0026#34;\r],\r\u0026#34;Resource\u0026#34;: [\r\u0026#34;*\u0026#34;\r]\r}\r]\r} Nhập AllowExternalDNSUpdates là Name. Nhập Allow access to Route53 Resources for ExternalDNS là Description. Nhấn Create policy.  Lưu lại ARN của policy để sử dụng sau.   Tạo Service Account.  Tạo Namespace mới cho phần này.  kubectl create ns fcj-external-dns-ingress-ns\rkubectl get ns fcj-external-dns-ingress-ns Tạo Service Account trên Namespace đã tạo. Thay thế với Policy Arn đã tạo.  eksctl create iamserviceaccount \\\r--name external-dns \\\r--namespace fcj-external-dns-ingress-ns \\\r--cluster fcj-elb-cluster \\\r--region ap-southeast-1 \\\r--attach-policy-arn \u0026lt;REPLACE-WITH-YOUR-CREATED-POLICY-ARN\u0026gt; \\\r--approve \\\r--override-existing-serviceaccounts Liệt kê Service Account đã tạo.  kubectl get sa external-dns -n fcj-external-dns-ingress-ns Xác minh rằng IAM Service Account đã tạo.  eksctl get iamserviceaccount --cluster fcj-elb-cluster --region ap-southeast-1 Lưu ROLE ARN của IAM Service Account external-dns để sử dụng sau.\nTạo tệp ExternalDNS manifest.  Tạo tệp 01-Deploy-ExternalDNS.yaml bên trong ingress/externaldns/externaldns-deployment.  touch ingress/externaldns/externaldns-deployment/01-Deploy-ExternalDNS.yaml\rls ingress/externaldns/externaldns-deployment Mở tệp 01-Deploy-ExternalDNS.yaml, dán đoạn code bên dưới. Thay thế với IAM Service Account đã tạo external-dns Arn. Sau đó lưu lại.  apiVersion: v1\rkind: ServiceAccount\rmetadata:\rname: external-dns\r# If you\u0026#39;re using Amazon EKS with IAM Roles for Service Accounts, specify the following annotation.\r# Otherwise, you may safely omit it.\rannotations:\r# Substitute your account ID and IAM service role name below. #Change-1: Replace with your IAM ARN Role for extern-dns\reks.amazonaws.com/role-arn: \u0026lt;REPLACE-WITH-YOUR-IAM-SERVICE-ACCOUNT-ARN\u0026gt;\r---\rapiVersion: rbac.authorization.k8s.io/v1\rkind: ClusterRole\rmetadata:\rname: external-dns\rrules:\r- apiGroups: [\u0026#34;\u0026#34;]\rresources: [\u0026#34;services\u0026#34;,\u0026#34;endpoints\u0026#34;,\u0026#34;pods\u0026#34;]\rverbs: [\u0026#34;get\u0026#34;,\u0026#34;watch\u0026#34;,\u0026#34;list\u0026#34;]\r- apiGroups: [\u0026#34;extensions\u0026#34;,\u0026#34;networking.k8s.io\u0026#34;]\rresources: [\u0026#34;ingresses\u0026#34;]\rverbs: [\u0026#34;get\u0026#34;,\u0026#34;watch\u0026#34;,\u0026#34;list\u0026#34;]\r- apiGroups: [\u0026#34;\u0026#34;]\rresources: [\u0026#34;nodes\u0026#34;]\rverbs: [\u0026#34;list\u0026#34;,\u0026#34;watch\u0026#34;]\r---\rapiVersion: rbac.authorization.k8s.io/v1\rkind: ClusterRoleBinding\rmetadata:\rname: external-dns-viewer\rroleRef:\rapiGroup: rbac.authorization.k8s.io\rkind: ClusterRole\rname: external-dns\rsubjects:\r- kind: ServiceAccount\rname: external-dns\rnamespace: fcj-external-dns-ingress-ns\r---\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: external-dns\rspec:\rstrategy:\rtype: Recreate\rselector:\rmatchLabels:\rapp: external-dns\rtemplate:\rmetadata:\rlabels:\rapp: external-dns spec:\rserviceAccountName: external-dns\rcontainers:\r- name: external-dns\rimage: k8s.gcr.io/external-dns/external-dns:v0.10.2\rargs:\r- --source=service\r- --source=ingress\r- --provider=aws\r- --aws-zone-type=public # only look at public hosted zones (valid values are public, private or no value for both)\r- --registry=txt\r- --txt-owner-id=my-hostedzone-identifier\rsecurityContext:\rfsGroup: 65534 # For ExternalDNS to be able to read Kubernetes and AWS token files Triển khai ExternalDNS  Thực thi câu lệnh bên dưới để triển khai ExternalDNS.  kubectl apply -f ingress/externaldns/externaldns-deployment -n fcj-external-dns-ingress-ns Liệt kê tất cả tài nguyên bên trong Namespace fcj-external-dns-ingress-ns.  kubectl get all -n fcj-external-dns-ingress-ns "
},
{
	"uri": "/vi/2-prerequiste/2.1-createcloud9workspace/",
	"title": "Tạo môi trường làm việc Cloud9",
	"tags": [],
	"description": "",
	"content": "Tạo môi trường làm việc Cloud9   Đi đến Cloud9 tại vùng ap-southeast-1.\n  Nhấn Create environment.   Tại trang Create environment, nhập FCJ-Workspace tại Name.\n  Nhập Workspace for hands on workshop tại Description.\n  Ở mục Environment type, giữ mặc định New EC2 instance.\n  Ở mục Instance type, chọn Additional instance types.\n  Ở mục Additional instance types, chọn t3.large.   Cuộn xuống cuối trang và nhấn Create.   Máy chủ làm việc đang được tạo.   Mất khoảng 2 phút để máy chủ tạo thành công.\n  Sau khi máy chủ tạo thành công, nhấn Open để bắt đầu.   "
},
{
	"uri": "/vi/2-prerequiste/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "Tổng quan Để tiến hành bài lab này, chúng ta phải chuẩn bị một máy chủ làm việc Cloud9 và tạo IAM Role cho máy chủ đó.\nNội dung  2.1 Tạo môi trường Cloud9 2.2 Cấu hình IAM Role 2.3 Cài đặt công cụ 2.4 Tạo Amazon EKS Cluster 2.5 Tạo ứng dụng  "
},
{
	"uri": "/vi/2-prerequiste/2.2-modifyiamrole/",
	"title": "Cấu hình IAM role",
	"tags": [],
	"description": "",
	"content": "Trong bước này, chúng ta sẽ tạo một IAM Role và gán nó cho máy chủ làm việc.\nTạo IAM role   Nhấn IAM để chuyển hướpg đến dịch vụ IAM.\n  Nhấn Role.\n  Nhấn Create role.   Ở mục Trusted entity type, chọn AWS service.\n  Ở mục Service or use case, chọn EC2.   Sau đó, nhấn Next.   Ở mục Permissions policies, chọn policy tên AdministratorAccess.   Sau đó, nhấn Next.   Tại trang Name, review, and create, nhập eksworkspace-administrator ở mục Role name .   Sau đó, cuộn xuống cuối trang và nhấn Create role.   Gán role cho máy chủ làm việc   Tại trang AWS Cloud9, nhấn Manage EC2 instance.   Bạn sẽ thấy máy chủ làm việc đã được tạo. Sau đó, nhấn chọn nó.\n  Nhấn Action.\n  Nhấn Security.\n  Nhấn Modify IAM role.   Chọn Role eksworkspace-administrator vừa được tạo ở bước trên.\n  Sau đó, nhấn Update IAM role.   IAM Role mới đã được cập nhật thành công.   Cập nhật cấu hình Cloud9 Cloud9 sẽ quản lý thông tin xác thực IAM tự dộng. Cấu hình mặc định này hiện không phù hợp với xác thực EKS thông qua IAM, chúng ta sẽ cần phải vô hiệu hóa tính năng này và sử dụng IAM Role.\n\r  Tại trang AWS Cloud9, nhấn AWS Cloud9.\n  Chọn Preferences.   Tại mục AWS Settings, vô hiệu hóa AWS managed temporary credentials.   Để đảm bảo rằng các thông tin xác thực tạm thời không còn lưu trữ trong Cloud9, chúng ta sẽ xóa tất cả thông tin xác thực đang tồn tại với dòng lệnh bên dưới.\n  rm -vf ${HOME}/.aws/credentials "
},
{
	"uri": "/vi/3-clbnlbwitheks/3.2-clbnlbwitheksfargate/",
	"title": "Dịch vụ Classic Load Balancer với Amazon EKS Cluster Fargate Profile",
	"tags": [],
	"description": "",
	"content": " Di chuyển tất cả tài nguyên của phần trước đến một thư mục mới tên ManagedNodeGroup.  mkdir ManagedNodeGroup\rmv app-deployment.yaml ManagedNodeGroup/\rmv ClassicLoadBalancer.yaml ManagedNodeGroup/\rls ManagedNodeGroup Tạo thư mục mới tên Fargate cho phần này.  mkdir Fargate Tạo Fargate Profile  Di chuyển đến thư mục Fargate và tạo một thư mục tên FargateProfile.  cd Fargate\rmkdir FargateProfile Tạo tệp fargate-profiles.yml bên trong FargateProfile.  touch FargateProfile/fargate-profiles.yml Mở tệp fargate-profiles.yml, dán đoạn code bên dưới. Sau đó lưu lại.  apiVersion: eksctl.io/v1alpha5\rkind: ClusterConfig\rmetadata:\rname: fcj-elb-cluster #Cluster Name\rregion: ap-southeast-1 # Region ID\rfargateProfiles:\r- name: fp-app1\rselectors:\r- namespace: ns-fcj-fp Để tạo Fargate Profile, bạn cần tạo namespace khớp với giá trị thông số đã cung cấp fargateProfiles.selectors.namespace trong tệp fargate-profiles.yml.  kubectl create ns ns-fcj-fp Liệt kê các namespace đã tạo.  kubectl get ns Tạo Fargate Profile.  eksctl create fargateprofile -f FargateProfile/fargate-profiles.yml Liệt kê Fargate Profile đã tạo.  eksctl get fargateprofile --cluster fcj-elb-cluster --region ap-southeast-1 -o yaml Tạo tệp Manifest Chúng ta sẽ sử dụng lại các tệp Manifest trong phần trước.\n Tạo thư mục tên kube-manifest.  mkdir kube-manifest Sao chép các tệp ở ManagedNodeGroup đến Fargate/kube-manifest.  cd ..\rcp -r ManagedNodeGroup/* Fargate/kube-manifest\rcd Fargate\rls kube-manifest Triển khai tài nguyên  Thực thi câu lệnh dưới để triển khai tài nguyên lên namespace ns-fcj-fp đã được định nghĩa ở Fargate Profile.  kubectl apply -n ns-fcj-fp -f kube-manifest Liệt kê tất cả tài nguyên đã tạo. Sẽ mất khoảng 3 phút cho việc tạo tài nguyên thành công.  kubectl get -n ns-fcj-fp deploy,pod,svc Có các tài nguyên được tạo trên Namespace fcj-app1:\n Một Deployment tên fcj-app1-deployment. Một Pod tên fcj-app1-deployment-7d9d4f7c44-lbqc6 với STATUS là Running. Một Service tên fcj-app1-clb-svc với TYPE là LoadBalancer và EXTERNAL-IP là a40e3cb6afdf84f60b8b8064284ad7cf-785887277.ap-southeast-1.elb.amazonaws.com.   Hãy truy cập Load Balancer. Có một Load Balancer được tạo với Type là classic là DNS name khớp với EXTERNAL-IP của fcj-app1-clb-svc Service.   Hãy truy cập đường dẫn http://\u0026lt;YOUR-EXTERNAL-IP\u0026gt;:8080 để kiểm tra kết quả.   Ứng dụng của bạn đã được triển khai với Classic Load Balancer thành công.\nHãy liệt kê tất cả Node đang chạy bên trong Cluster.  kubectl get nodes Chúng có có 2 loại Worker Node ở đây. Một loại thuộc về EC2 Managed Node Group với định dạng tên là ip-\u0026lt;PRIVATE-IP\u0026gt;.ap-southeast-1.compute.internal và loại còn lại thuộc về Fargate Profile với định dạng tên là fargate-ip-\u0026lt;PRIVATE-IP\u0026gt;.ap-southeast-1.compute.internal. Hãy lưu lại tên của Fargate Profile Node. Chúng ta sẽ khám phá Application Pod để thấy Node nào mà nó đang chạy trên.\nLiệt kê Application Pod và lấy Pod Name.  kubectl get -n ns-fcj-fp pod Khám phá Pod.  kubectl describe -n ns-fcj-fp pod \u0026lt;REPLACE-WITH-POD-NAME\u0026gt; Hãy so sánh Fargate Profile Node Name và giá trị của mục Node để xác minh rằng chúng khớp nhau.\nChúc mừng, bạn đã triển khai và tích hợp Classic Load Balancer trên Fargate Node thành công. Dọn dẹp  Thực thi câu lệnh bên dưới để xóa các tài nguyên đã tạo trên namespace ns-fcj-fp.  kubectl delete -n ns-fcj-fp -f kube-manifest Liệt kê lại tất cả tài nguyên để đảm bảo rằng chúng đã được xóa.  kubectl get deploy,pod,svc -n ns-fcj-fp  Truy cập Load Balancer để xác minh rằng Classic Load Balancer vừa tạo đã được tự động xóa khi fcj-app1-clb-svc Service bị xóa.   Xóa Fargate Profile. Sẽ mất khoảng 5 phút để hoàn tất.\n  eksctl delete fargateprofile --name fp-app1 --cluster fcj-elb-cluster --region ap-southeast-1 --wait Liệt Fargate Profile để đảm bảo nó đã được xóa.  eksctl get fargateprofile --cluster fcj-elb-cluster --region ap-southeast-1 -o yaml Xóa Namespace đã tạo.  kubectl delete ns ns-fcj-fp Liệt kê namespace để đảm bảo nó đã được xóa  kubectl get ns "
},
{
	"uri": "/vi/6-nlbwitheks/6.2-nlbwitheksfargate/",
	"title": "Dịch vụ Network Load Balancer với Amazon EKS Cluster Fargate Node",
	"tags": [],
	"description": "",
	"content": "Triển khai dịch vụ Network Load Balancer cơ bản với Amazon EKS Cluster Fargate Node Chỉnh sửa tệp Manifest. Bởi vì Fargate Profile đã được tạo ở phần trước, nên chúng ta sẽ sử dụng lại nó. Hãy thêm labels là runon: Fargate cho tệp manifest ứng dụng.\n  Mở tệp tên app-deployment.yaml bên trong nlb/ManagedNodeGroup. Thêm labels là runon: Fargate tại thông số metadata.labels và spec.template.metadata.labels. Sau đó lưu lại.   Mở tệp NetworkLoadBalancer.yaml bên trong nlb/ManagedNodeGroup. Thêm labels là runon: Fargate tại thông số metadata. Thêm đó, chuyển thành ghi chú định nghĩa External DNS ở dòng 26. Sau đó lưu lại.   Triển khai tài nguyên.  Triển khai tài nguyên trên Namespace fcj-external-dns-ingress-ns.  kubectl apply -f nlb/ManagedNodeGroup -n fcj-external-dns-ingress-ns Liệt kê các tài nguyên trên Namespace fcj-external-dns-ingress-ns.  kubectl get all -n fcj-external-dns-ingress-ns 3. Liệt kê tất cả Node trong Cluster.\nkubectl get node -o wide Có một Fargate Instance được tạo ra cho ứng dụng.\nHãy khám phá Pod để xác minh rằng nó chạy trên Fargate Instance. Thay thế với Pod ID và xác minh rằng IP của Pod khớp với INTERNAL-IP của Fargate Instance và Node của Pod là tên của Fargate Instance.  kubectl describe pod \u0026lt;POD-ID\u0026gt; -n fcj-external-dns-ingress-ns Truy cập Load Balancer để xác minh Network Load Balancer được tạo.   Kiểm tra tài nguyên.  Truy cập URL của ứng dụng http://\u0026lt;YOUR-NETWORK-LOAD-BALANCER-URL\u0026gt;:8080.   Ứng dụng hoạt động!\n(Optional) Integrate with ExternalDNS service. Modify Manifest file.  Mở tệp NetworkLoadBalancer.yaml, bỏ chú thích định nghĩa ExternalDNS ở dòng 26 và thay thế với fcjnlbfargate.\u0026lt;YOUR-DOMAIN-NAME\u0026gt;. Sau đó lưu lại.  Triển khai lại tài nguyên.  Thực thi câu lệnh bên dưới để triển khai lại tài nguyên Namespace fcj-external-dns-ingress-ns.  kubectl apply -f nlb/ManagedNodeGroup -n fcj-external-dns-ingress-ns\rkubectl get all -n fcj-external-dns-ingress-ns Service tên fcj-basic-nlb-service sẽ được cấu hình.\nKiểm tra kết quả.  Truy cập http://fcjnlbfargate.\u0026lt;YOUR-DOMAIN-NAME\u0026gt;:8080 để xác minh kết quả.   Dọn dẹp Xóa các tài nguyên đã tạo.  Xóa các tài nguyên đã tạo trên Namespace fcj-external-dns-ingress-ns.  kubectl delete -f nlb/ManagedNodeGroup -n fcj-external-dns-ingress-ns\rkubectl get all -n fcj-external-dns-ingress-ns Xóa ExternalDNS Service  Xóa ExternalDNS Service trên Namespace fcj-external-dns-ingress-ns.  kubectl delete -f ingress/externaldns/externaldns-deployment -n fcj-external-dns-ingress-ns\rkubectl get all -n fcj-external-dns-ingress-ns Xóa Namespace đã tạo.  Xóa Namespace đã tạo fcj-external-dns-ingress-ns.  kubectl delete ns fcj-external-dns-ingress-ns\rkubectl get ns fcj-external-dns-ingress-ns Chúc mừng, bạn đã triển khai ứng dụng lên Amazon EKS Cluster trên Fargate Node với Ingress và ExternalDNS Service thành công. "
},
{
	"uri": "/vi/5-dnsingresswitheks/5.2-useexternaldnsasingress/",
	"title": "Sử dụng ExternalDNS như Ingress Service",
	"tags": [],
	"description": "",
	"content": "Tạo tệp Manifest.  Tạo một thư mục làm việc mới.  mkdir ingress/externaldns/externaldns-ingress\rls ingress/externaldns Sao chép tất cả tài nguyên trong ingress/context-based-routing-ingress đến ingress/externaldns/externaldns-ingress.  cp ingress/context-based-routing-ingress/* ingress/externaldns/externaldns-ingress\rls ingress/externaldns/externaldns-ingress Mở tệp 05-ALB-ingress.yaml, thêm đoạn chú thích bên dưới. Thay thế với DNS Name của bạn.  # External DNS - For creating a Record Set in Route53\rexternal-dns.alpha.kubernetes.io/hostname: \u0026lt;REPLACE-WITH-YOUR-DNSNAME\u0026gt; Triển khai tài nguyên.  Triển khai tài nguyên trên Namespace fcj-external-dns-ingress-ns.  kubectl apply -f ingress/externaldns/externaldns-ingress -n fcj-external-dns-ingress-ns Liệt kê tất cả tài nguyên đã tạo trên Namespace fcj-external-dns-ingress-ns.  kubectl get all -n fcj-external-dns-ingress-ns Truy cập Route53 nhấn vào Host Zone của bạn để xác minh có một bản ghi DNS mới firstcloudjourney được tạo.  Kiểm tra kết quả.   Truy cập http://\u0026lt;YOUR-DNS-NAME\u0026gt;/app1.   Truy cập http://\u0026lt;YOUR-DNS-NAME\u0026gt;/app2.   Chúc mừng, bạn đã triển khai ứng dụng với DNS Name thành công. Dọn dẹp.  Xóa các tài nguyên đã tạo.  kubectl delete -f ingress/externaldns/externaldns-ingress -n fcj-external-dns-ingress-ns\rkubectl get all -n fcj-external-dns-ingress-ns Sẽ giữ lại các tài nguyên liên quan đến dịch vụ external-dns cho các phần tiếp theo.\nĐi đến Route53 nhấn vào Host Zone của bạnđể xác minh rằng DNS Record firstcloudjourney đã tự động xóa khi Ingress Service xóa.   "
},
{
	"uri": "/vi/4-ingresswitheks/4.2-basciingress/",
	"title": "Tạo Ingress cơ bản",
	"tags": [],
	"description": "",
	"content": "Ở phần trước, bạn đã cài đặt AWS Load Balancer Controller và tạo một Ingress Class. Trong phần này, chúng ta sẽ tạo một Ingress cơ bản để tích hợp với ứng dụng chúng ta.\nTạo tệp Manifest  Tạo một thư mục làm việc cho phần này.  mkdir ingress/basic-ingress Tạo một tệp manifest tên 01-App1-Deployment.yaml để triển khai ứng dụng.  touch ingress/basic-ingress/01-App1-Deployment.yaml 3.Mở tệp 01-App1-Deployment.yaml, dán đoạn code bên dưới. Sau đó lưu lại. Đừng quên thay thế với Container Image URL hoặc có thể sử dụng firstcloudjourneypcr/fcj-elbeks-workshop-basicapp:v1cho mục đích kiểm thử.\napiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: fcj-app1-deployment\rlabels:\rapp: fcj-app1\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: fcj-app1\rtemplate:\rmetadata:\rlabels:\rapp: fcj-app1\rspec:\rcontainers:\r- name: fcj-app1\rimage: \u0026lt;REPLACE-WITH-YOUR-CONTAINER-IMAGE-URL\u0026gt;\rports:\r- containerPort: 8080 Tạo tệp tên 02-NodePort-svc.yaml để tạo NodePort cho Application Pod.  touch ingress/basic-ingress/02-NodePort-svc.yaml Mở tệp 02-NodePort-svc.yaml, dán đoạn code bên dưới. Sau đó lưu lại.  apiVersion: v1\rkind: Service\rmetadata:\rname: fcj-app1-nodeport-service\rlabels:\rapp: fcj-app1\rspec:\rtype: NodePort\rselector:\rapp: fcj-app1\rports:\r- port: 8080\rtargetPort: 8080 Tạo tệp tên 03-ALB-ingress.yaml để tạo và tích hợp ALB Ingress Service cho ứng dụng của bạn.  touch ingress/basic-ingress/03-ALB-ingress.yaml 7.Mở tệp 03-ALB-ingress.yaml, dán đoạn code bên dưới. Sau đó lưu lại.\napiVersion: networking.k8s.io/v1\rkind: Ingress\rmetadata:\rname: fcj-app1-ingress\rlabels:\rapp: fcj-app1\rannotations:\r# Load Balancer Name\ralb.ingress.kubernetes.io/load-balancer-name: app1ingressrules\r# Ingress Core Settings\ralb.ingress.kubernetes.io/scheme: internet-facing\r# Health Check Settings\ralb.ingress.kubernetes.io/healthcheck-protocol: HTTP alb.ingress.kubernetes.io/healthcheck-port: traffic-port\ralb.ingress.kubernetes.io/healthcheck-path: / alb.ingress.kubernetes.io/healthcheck-interval-seconds: \u0026#39;15\u0026#39;\ralb.ingress.kubernetes.io/healthcheck-timeout-seconds: \u0026#39;5\u0026#39;\ralb.ingress.kubernetes.io/success-codes: \u0026#39;200\u0026#39;\ralb.ingress.kubernetes.io/healthy-threshold-count: \u0026#39;2\u0026#39;\ralb.ingress.kubernetes.io/unhealthy-threshold-count: \u0026#39;2\u0026#39;\rspec:\ringressClassName: my-aws-ingress-class # Ingress Class\rrules:\r- http:\rpaths:\r- path: /\rpathType: Prefix\rbackend:\rservice:\rname: fcj-app1-nodeport-service\rport:\rnumber: 8080 Triển khai tài nguyên.  Đầu tiên, tạo Namespace mới tên fcj-basic-ingress-ns để triển khai tài nguyên cho phần này.  kubectl create ns fcj-basic-ingress-ns Liệt kê Namespace đã tạo.  kubectl get ns Liệt kê tất cả tài nguyên trong Namespace fcj-basic-ingress-ns để đảm bảo rằng chưa có tài nguyên nào được tạo.  kubectl get ingress,deploy,svc,pod -n fcj-basic-ingress-ns Đi đến Load Balancers để kiểm tra chưa có ALB nào được tạo.  Bây giờ, hãy tạo tài nguyên trong Namespace fcj-basic-ingress-ns.  kubectl apply -f ingress/basic-ingress -n fcj-basic-ingress-ns Liệt kê tài nguyên được tạo.  kubectl get ingress,deploy,svc,pod -n fcj-basic-ingress-ns Các tài nguyên được tạo:\n Một Ingress tên fcj-app1-ingress với Class là my-aws-ingress-class, ADDRESS là app1ingressrules-2077624863.ap-southeast-1.elb.amazonaws.com và PORTS là 80. Một Deployment tên fcj-app1-deployment. Một Service tên fcj-app1-nodeport-service với TYPE f NodePort. Một Pod tên fcj-app1-deployment-xxxxxxxxxx-xxxxx.  Đi đến Load Balancers để kiểm tra kết quả.   Application Load Balancer tên fcj-app1-ingress, với Type là application, được tạo tự động khi Ingress được tạo.\nChờ đến khi State của Application Load Balancer tên fcj-app1-ingress đổi thành Active. Nhấn vào nó.   Có một Listener. Nhấn vào.   Có một Target Group được định tuyến bởi Path Pattern /. Nhấn vào.   Ứng dụng được triển khai trên EC2 Instance của Node Group với Port number và Health status là Healthy.   Hãy kiểm tra kết quả bằng việc truy cập vào URL ứng dụng http://\u0026lt;REPLACE-WITH-YOUR-INGRESS-ADDRESS\u0026gt;.\n  Chúc mừng, bạn đã triển khai ứng dụng của bạn và tích hợp với Ingress (AWS Application Load Balancer) Service thành công. Dọn dẹp.  Thực thi câu lệnh bên dưới để xóa tất cả tài nguyên đã tạo bên trong Namespace fcj-basic-ingress-ns.  kubectl delete -f ingress/basic-ingress -n fcj-basic-ingress-ns Liệt kê lại tài nguyên để đảm bảo rằng tất cả đã được xóa.  kubectl get ingress,deploy,svc,pod -n fcj-basic-ingress-ns Xóa Namespace fcj-basic-ingress-ns.  kubectl delete ns fcj-basic-ingress-ns Đảm bảo rằng nó đã được xóa.  kubectl get ns fcj-basic-ingress-ns Đi đến Load Balancers để xác minh rằng Application Load Balancer đã được tự động xóa khi Ingress xóa.   "
},
{
	"uri": "/vi/4-ingresswitheks/4.3-conextbasedroutingingress/",
	"title": "Context Path Based Routing Ingress trên EC2 Managed NodeGroup",
	"tags": [],
	"description": "",
	"content": "Chúng ta sẽ triển khai tất cả 2 ứng dụng trong với định tuyến dựa trên đường dẫn được kích hoạt trên Ingress Controller:\n /app1/* - sẽ đi đến ứng dụng App1. /app2/* - sẽ đi đến ứng dụng App2.  Tạo tệp Manifest.  Tạo thư mục làm việc mới cho phần này.  mkdir ingress/context-based-routing-ingress Tạo tệp tên 01-App1-Deployment.yaml bên trong ingress/context-based-routing-ingress.  touch ingress/context-based-routing-ingress/01-App1-Deployment.yaml Mở tệp 01-App1-Deployment.yaml, dán đoạn code bên dưới. Sau đó lưu lại. Chúng ta sẽ sử dụng container image URL stacksimplify/kube-nginxapp1:1.0.0 cho mục đích thử nghiệm.  apiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: fcj-app1-deployment\rlabels:\rapp: fcj-app1\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: fcj-app1\rtemplate:\rmetadata:\rlabels:\rapp: fcj-app1\rspec:\rcontainers:\r- name: fcj-app1\rimage: stacksimplify/kube-nginxapp1:1.0.0\rports:\r- containerPort: 80 Tạo tệp tên 02-App1-NodePort-svc.yaml bên trong ingress/context-based-routing-ingress.  touch ingress/context-based-routing-ingress/02-App1-NodePort-svc.yaml Mở tệp 02-App1-NodePort-svc.yaml, dán đoạn code bên dưới. Sau đó lưu lại.  apiVersion: v1\rkind: Service\rmetadata:\rname: fcj-app1-nodeport-service\rlabels:\rapp: fcj-app1\rannotations: alb.ingress.kubernetes.io/healthcheck-path: /app1/index.html\rspec:\rtype: NodePort\rselector:\rapp: fcj-app1\rports:\r- port: 80\rtargetPort: 80 Tạo tệp tên 03-App2-Deployment.yaml bên trong ingress/context-based-routing-ingress.  touch ingress/context-based-routing-ingress/03-App1-Deployment.yaml Mở tệp 03-App2-Deployment.yaml, dán đoạn code bên dưới. Lưu lại. Chúng ta sẽ sử dụng container image URL stacksimplify/kube-nginxapp2:1.0.0 cho mục đích thử nghiệm.  apiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: fcj-app2-deployment\rlabels:\rapp: fcj-app2\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: fcj-app2\rtemplate:\rmetadata:\rlabels:\rapp: fcj-app2\rspec:\rcontainers:\r- name: fcj-app2\rimage: stacksimplify/kube-nginxapp2:1.0.0\rports:\r- containerPort: 80 Tạo tệp tên 04-App2-NodePort-svc.yaml bên trong ingress/context-based-routing-ingress.  touch ingress/context-based-routing-ingress/04-App2-NodePort-svc.yaml Mở tệp 04-App2-NodePort-svc.yaml, dán đoạn code bên dưới. Sau đó lưu lại.  apiVersion: v1\rkind: Service\rmetadata:\rname: fcj-app2-nodeport-service\rlabels:\rapp: fcj-app2\rannotations: alb.ingress.kubernetes.io/healthcheck-path: /app2/index.html\rspec:\rtype: NodePort\rselector:\rapp: fcj-app2\rports:\r- port: 80\rtargetPort: 80 Tạo tệp tên 05-ALB-ingress.yaml bên trong ingress/context-based-routing-ingress.  touch ingress/context-based-routing-ingress/05-ALB-ingress.yaml Mở tệp 05-ALB-ingress.yaml, dán đoạn code bên dưới. Sau đó lưu lại.  apiVersion: networking.k8s.io/v1\rkind: Ingress\rmetadata:\rname: fcj-context-based-routing-ingress\rannotations:\r# Load Balancer Name\ralb.ingress.kubernetes.io/load-balancer-name: fcj-context-based-routing\r# Ingress Core Settings\ralb.ingress.kubernetes.io/scheme: internet-facing\r# Health Check Settings\ralb.ingress.kubernetes.io/healthcheck-protocol: HTTP alb.ingress.kubernetes.io/healthcheck-port: traffic-port\ralb.ingress.kubernetes.io/healthcheck-interval-seconds: \u0026#39;15\u0026#39;\ralb.ingress.kubernetes.io/healthcheck-timeout-seconds: \u0026#39;5\u0026#39;\ralb.ingress.kubernetes.io/success-codes: \u0026#39;200\u0026#39;\ralb.ingress.kubernetes.io/healthy-threshold-count: \u0026#39;2\u0026#39;\ralb.ingress.kubernetes.io/unhealthy-threshold-count: \u0026#39;2\u0026#39;\rspec:\ringressClassName: my-aws-ingress-class # Ingress Class\rrules:\r- http:\rpaths:\r- path: /app1\rpathType: Prefix\rbackend:\rservice:\rname: fcj-app1-nodeport-service\rport:\rnumber: 80\r- path: /app2\rpathType: Prefix\rbackend:\rservice:\rname: fcj-app2-nodeport-service\rport:\rnumber: 80 Triển khai tài nguyên.  Tạo Namespace mới để triển khai tài nguyên.  kubectl create ns fcj-context-based-routing-ns Liệt kê Namespace đã tạo.  kubectl get ns fcj-context-based-routing-ns Triển khai tài nguyên lên Namespace đã tạo.  kubectl apply -f ingress/context-based-routing-ingress -n fcj-context-based-routing-ns Liệt kê tài nguyên đã tạo.  kubectl get ingress,svc,deploy,pod -n fcj-context-based-routing-ns Các tài nguyên được tạo:\n Một Ingress tên fcj-context-based-routing-ingress với ADDRESS là fcj-context-based-routing-1220596484.ap-southeast-1.elb.amazonaws.com. Hai Service tên fcj-app1-nodeport-service và fcj-app2-nodeport-service cho Application App1 và App2. Hai Deploymet tên fcj-app1-deployment và fcj-app2-deployment, và 2 Pod được tạo cho mỗi Application.   Đi đến Load Balancers để xác minh có một Application Load Balancer được tạo tự động.   Xác minh Listener Rule của Application Load Balancer. Có 2 quy tắc được tạo: Một cho App1 và một cho App2.   Truy cập tới Ingress Address để kiểm tra kết quả:\n   Truy cập với /app1 để đi đến Application App1. Truy cập với /app2 để đi đến Application App2.   Dọn dẹp  Thực thi câu lệnh bên dưới để xóa tài nguyên trên Namespace fcj-context-based-routing-ns.  kubectl delete -f ingress/context-based-routing-ingress -n fcj-context-based-routing-ns Liệt kê tài nguyên lần nữa để kiểm tra tất cả đã được xóa.  kubectl get ingress,svc,deploy,pod -n fcj-context-based-routing-ns Xóa Namespace fcj-context-based-routing-ns.  kubectl delete ns fcj-context-based-routing-ns Đảm bảo rằng nó đã được xóa.  kubectl get ns fcj-context-based-routing-ns Đi đến Load Balancers để xác minh Application Load Balancer được xóa tự động khi Ingress bị xóa.   "
},
{
	"uri": "/vi/2-prerequiste/2.3-installation/",
	"title": "Cài đặt công cụ",
	"tags": [],
	"description": "",
	"content": "Trong bài thực hành này, chúng ta sẽ cài đặt các công cụ cần thiết: awscli, kubectl và eksctl.\nNâng cấp awscli  Sao chép và dán dòng lệnh dưới đây vào cửa sổ lệnh Cloud8 để nâng cấp awscli.  sudo pip install --upgrade awscli \u0026amp;\u0026amp; hash -r Cài đặt kubectl  Tại cửa sổ lệnh Cloud9, thực hiện câu lệnh này để cài đặt kubectl.   Nâng cấp các gói tin trong máy chủ.  sudo yum update  Cài đặt kubectl.  curl -LO https://dl.k8s.io/release/v1.30.0/bin/linux/amd64/kubectl sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl Kiểm tra phiên bản của kubectl.  kubectl version --client Cài đặt eksctl  Tại cửa sổ lệnh Cloud9, thực hiện câu lệnh này để cài đặt eksctl.   Tải xuống và giải nén bản phát hành mới nhất của eksctl bằng lệnh sau.  curl --silent --location \u0026#34;https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz\u0026#34; | tar xz -C /tmp  Di chuyển nhị phân được trích xuất sang /usr/local/bin.  sudo mv /tmp/eksctl /usr/local/bin  Kiểm thử việc cài đặt đã thành công bằng câu lệnh  eksctl version "
},
{
	"uri": "/vi/3-clbnlbwitheks/",
	"title": "Dịch vụ Classic Load Balancer với Amazon EKS Cluster",
	"tags": [],
	"description": "",
	"content": "Tổng quan Trong phần này, chúng ta sẽ tạo một Classic Load Balancer, mà Amazon EKS Cluster sẽ tích hợp với, để công khai truy cập tới Application Pod trong Private Subnet. Content  3.1. Dịch vụ Classic Load Balancer với Amazon EKS Cluster EC2 Managed NodeGroup 3.2. Dịch vụ Classic Load Balancer với Amazon EKS Cluster Fargate Profile  "
},
{
	"uri": "/vi/5-dnsingresswitheks/5.3-namebasedvirtualhostrouting/",
	"title": "Name Based Virtual Host Routing",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ triển khai định tuyến Host Header sử dụng Ingress.\nTạo tệp Manifest.  Tạo thư mục làm việc mới cho phần này.  mkdir ingress/externaldns/host-header-routing-ingress\rls ingress/externaldns Chúng ta sẽ sử dụng lại các tài nguyên của phần trước. Hãy sao chép tất cả tài nguyên bên trong ingress/externaldns/externaldns-ingress vào ingress/externaldns/host-header-routing-ingress.  cp ingress/externaldns/externaldns-ingress/* ingress/externaldns/host-header-routing-ingress\rls ingress/externaldns/host-header-routing-ingress Mở tệp 05-ALB-ingress.yaml, xóa tất cả định nghĩa của nó và thay thế bằng đoạn code bên dưới. Sau đó, thay thế \u0026lt;REPLACE-WITH-YOUR-HOST-HEADER-APP1\u0026gt; và \u0026lt;REPLACE-WITH-YOUR-HOST-HEADER-APP2\u0026gt; với Host Header của bạn cho mỗi ứng dụng.  apiVersion: networking.k8s.io/v1\rkind: Ingress\rmetadata:\rname: fcj-host-header-based-routing-ingress\rannotations:\r# Load Balancer Name\ralb.ingress.kubernetes.io/load-balancer-name: fcj-host-header-based-routing\r# Ingress Core Settings\ralb.ingress.kubernetes.io/scheme: internet-facing\r# Health Check Settings\ralb.ingress.kubernetes.io/healthcheck-protocol: HTTP alb.ingress.kubernetes.io/healthcheck-port: traffic-port\ralb.ingress.kubernetes.io/healthcheck-interval-seconds: \u0026#39;15\u0026#39;\ralb.ingress.kubernetes.io/healthcheck-timeout-seconds: \u0026#39;5\u0026#39;\ralb.ingress.kubernetes.io/success-codes: \u0026#39;200\u0026#39;\ralb.ingress.kubernetes.io/healthy-threshold-count: \u0026#39;2\u0026#39;\ralb.ingress.kubernetes.io/unhealthy-threshold-count: \u0026#39;2\u0026#39;\rspec:\ringressClassName: my-aws-ingress-class # Ingress Class\rrules:\r- host: \u0026lt;REPLACE-WITH-YOUR-HOST-HEADER-APP1\u0026gt;\rhttp:\rpaths:\r- path: /\rpathType: Prefix\rbackend:\rservice:\rname: fcj-app1-nodeport-service\rport:\rnumber: 80\r- host: \u0026lt;REPLACE-WITH-YOUR-HOST-HEADER-APP2\u0026gt;\rhttp:\rpaths:\r- path: /\rpathType: Prefix\rbackend:\rservice:\rname: fcj-app2-nodeport-service\rport:\rnumber: 80 Triển khai tài nguyên.  Triển khai tài nguyên trên Namespace fcj-external-dns-ingress-ns.  kubectl apply -f ingress/externaldns/host-header-routing-ingress -n fcj-external-dns-ingress-ns Liệt kê tất cả tài nguyên đã tạo.  kubectl get all -n fcj-external-dns-ingress-ns Truy cập Route53 nhấn vào Host Zone của bạn để xác minh có 2 DNS Records mới firstcloudjourney-app1 và firstcloudjourney-app2 được tạo ra.   Kiểm tra kết quả.   Truy cập http://firstcloudjourney-app1.\u0026lt;YOUR-DNS-NAME\u0026gt;/app1.   Khi bạn khi cập http://firstcloudjourney-app1.\u0026lt;YOUR-DNS-NAME\u0026gt;/app2. Kết quả trả về là thất bại.   Truy cập http://firstcloudjourney-app2.\u0026lt;YOUR-DNS-NAME\u0026gt;/app2.   Khi bạn khi cập http://firstcloudjourney-app2.\u0026lt;YOUR-DNS-NAME\u0026gt;/app1. Kết quả trả về là thất bại.   Chúc mừng, bạn đã triển khai ứng dụng với định tuyến tên miền dựa trên máy chủ ảo thành công. Dọn dẹp.  Xóa các tài nguyên đã tạo.  kubectl delete -f ingress/externaldns/host-header-routing-ingress -n fcj-external-dns-ingress-ns\rkubectl get all -n fcj-external-dns-ingress-ns Sẽ giữ lại các tài nguyên liên quan đến dịch vụ external-dns cho các phần tiếp theo.\nĐi đến Route53 nhấn vào Host Zone để xác mình DNS Records được tạo firstcloudjourney-app1 và firstcloudjourney-app2 tự động xóa khi Ingress Service bị xóa.   "
},
{
	"uri": "/vi/4-ingresswitheks/4.4-ingresswithfargate/",
	"title": "Context Path Based Routing Ingress trên Fargate Profile",
	"tags": [],
	"description": "",
	"content": "Ở phần trước, chúng ta đã triển khai 2 ứng dụng trên kubernetes với định tuyến dựa trên đường dẫn với Ingress Controller trên EC2 Managed Node. Ở phần này, chúng ta sẽ triển khai chúng trên Fargate Profile.\nTạo tệp Manifest  Tạo thư mục làm việc mới cho phần này.  mkdir ingress/context-based-routing-ingress-on-fargate Tạo tệp manifest Fargate Profile.  mkdir ingress/context-based-routing-ingress-on-fargate/fargate-profile\rls ingress/context-based-routing-ingress-on-fargate\rtouch ingress/context-based-routing-ingress-on-fargate/fargate-profile/fargate-profile.yaml\rls ingress/context-based-routing-ingress-on-fargate/fargate-profile Mở tệp fargate-profile.yaml, dán đoạn code bên dưới. Sau đó lưu lại.  apiVersion: eksctl.io/v1alpha5\rkind: ClusterConfig\rmetadata:\rname: fcj-elb-cluster\rregion: ap-southeast-1\rspec:\r- name: fcj-fp\rselectors:\r- namespace: fcj-context-path-based-routing-fargate-ns Tạo một thư mục mới để chưa tệp manifest ứng dụng.  mkdir ingress/context-based-routing-ingress-on-fargate/application\rls ingress/context-based-routing-ingress-on-fargate Sao chép tất cả tệp manifest ứng dụng ở phần trước bên trong ingress/context-based-routing-ingress đến ingress/context-based-routing-ingress-on-fargate/application.  cp ingress/context-based-routing-ingress/* ingress/context-based-routing-ingress-on-fargate/application\rls ingress/context-based-routing-ingress-on-fargate/application Triển khai tài nguyên Tạo Namespace để triển khai tài nguyên.  Tạo Namespace tên fcj-context-path-based-routing-fargate-ns, khớp với giá trị thông số spec.selectors.namespace trong ingress/context-based-routing-ingress-on-fargate/fargate-profile/fargate-profile.yaml.  kubectl create ns fcj-context-path-based-routing-fargate-ns Liệt kê Namespace đã tạo.  kubectl get ns fcj-context-path-based-routing-fargate-ns Tạo Fargate Profile.  Liệt kê Fargate Profile trong EKS Cluster.  eksctl get fargateprofile --cluster fcj-elb-cluster --region ap-southeast-1 Tạo Fargate Profile bên trong EKS Cluster.  eksctl create fargateprofile -f ingress/context-based-routing-ingress-on-fargate/fargate-profile/fargate-profile.yaml Liệt kê lại Fargate Profile trong EKS Cluster.  eksctl get fargateprofile --cluster fcj-elb-cluster --region ap-southeast-1 Triển khai tài nguyên.  Thực thi câu lệnh bên dưới để triển khai tài nguyên lên Namespace fcj-context-path-based-routing-fargate-ns.  kubectl apply -f ingress/context-based-routing-ingress-on-fargate/application -n fcj-context-path-based-routing-fargate-ns Liệt kê tài nguyên đã tạo.  kubectl get ingress,svc,deploy,pod -n fcj-context-path-based-routing-fargate-ns Các tài nguyên đã tạo:\n Một Ingress tên fcj-context-based-routing-ingress với ADDRESS là fcj-context-based-routing-427025104.ap-southeast-1.elb.amazonaws.com. Hai Service tên fcj-app1-nodeport-service và fcj-app2-nodeport-service cho ứng dụng App1 và App2. Hai Deploymet tên fcj-app1-deployment và fcj-app2-deployment, và hai Pod cho mỗi ứng dụng.  Hãy liệt kê Node hiện tại để xác minh rằng Fargate Node đã được tạo.  kubectl get node -o wide Có hai Fargate Node được tạo.\nKiểm tra kết quả.  Truy cập http://\u0026lt;REPLACE-WITH-INGRESS-ADDRESS\u0026gt;/app1 để kiểm tra kết quả.  Truy cập http://\u0026lt;REPLACE-WITH-INGRESS-ADDRESS\u0026gt;/app2 để kiểm tra kết quả.  Chúc mừng, bạn đã triển khai ứng dụng với Ingress Service lên Fargate Node thành công. Dọn dẹp.  Thực thi câu lệnh dưới để xóa tài nguyên đã tạo.  kubectl delete -f ingress/context-based-routing-ingress-on-fargate/application -n fcj-context-path-based-routing-fargate-ns\rkubectl get ingress,svc,deploy,pod -n fcj-context-path-based-routing-fargate-ns Tất cả đã được xóa.\nXóa Fargate Profile.  eksctl delete fargateprofile --name fcj-fp --cluster fcj-elb-cluster --region ap-southeast-1 --wait\reksctl get fargateprofile --cluster fcj-elb-cluster --region ap-southeast-1 Xóa Namespace đã tạo.  kubectl delete ns fcj-context-path-based-routing-fargate-ns\rkubectl get ns fcj-context-path-based-routing-fargate-ns Xác minh rằng Fargate Node đã được xóa.  kubectl get node -o wide Chỉ còn EC2 Managed Node.\nĐi đến Load Balancers để xác minh rằng Application Load Balancer được xóa tự động khi Ingress Service bị xóa.   "
},
{
	"uri": "/vi/4-ingresswitheks/",
	"title": "Dịch vụ Ingress với Amazon EKS Cluster",
	"tags": [],
	"description": "",
	"content": "Tổng quan Khi bạn tạo một Kubernetes Ingress, một AWS Application Load Balancer (ALB) sẽ được cung cập để cân bằng lưu lượng truy cập ứng dụng, ALBs có thể được sử dụng với Pod mà được triển khai trên Node hoặc trên AWS Fargte. Bạn có thể triển khai một ALB trên public hoặc private subnet.\nNội dung  4.1 Cài đặt AWS Load Balancer Controller 4.2 Tạo Ingress cơ bản 4.3 Context Path Based Routing Ingress trên EC2 Managed NodeGroup 4.4 Context Path Based Routing Ingress trên Fargate Profile  "
},
{
	"uri": "/vi/5-dnsingresswitheks/5.4-sslandssldirect/",
	"title": "SSL và SSL Redirect",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ tạo một chứng chỉ SSL cho ứng dụng. Sau đó, chuyển hướng tất cả lưu lượng yêu cầu HTTP đến cổng HTTPS.\nTích hợp chứng chỉ SSL lên ứng dụng của bạn. Create a SSL Certificate in Certificate Manager   Đi đến AWS Certificate Manager. Nhấn Request a certificate.   Tại Request certificate, nhấn Next.   Nhập tên miền với định dạng *.\u0026lt;YOUR-DOMAIN-NAME\u0026gt; tại mục Fully qualified domain name.   Giữ mặc định ở các mục còn lại. Sau đó nhấn Request.   Certificate của bạn đã được tạo nhưng ở trạng thái Pending validation.   Hãy tạo bản ghi mới bên trong Route53 để xác thực. Nhấn Create records in Route 53.   Nhấn Create records.   Đi đến Route 53, nhấn Host Zone của bạn để thấy có một bản ghi mới được tạo bởi AWS Certificate Manager.   Trở lại AWS Certificate Manager để thấy trạng thái chứng chỉ bây giờ là Issued.\n  Sẽ mất khoảng 10 phút để xác thực thành công.\n\rLưu lại ARN để sử dụng sau.   Tạo tệp Manifest.  Tạo thư mục mới cho phần này.  mkdir ingress/externaldns/ssl-and-ssl-redirect\rls ingress/externaldns Chúng ta sẽ sử dụng lại các tài nguyên của phần trước. Hãy sao chép tất cả tài nguyên bên trong ingress/externaldns/host-header-routing-ingress đến ingress/externaldns/ssl-and-ssl-redirect.  cp ingress/externaldns/host-header-routing-ingress/* ingress/externaldns/ssl-and-ssl-redirect\rls ingress/externaldns/ssl-and-ssl-redirect Mở tệp 05-ALB-ingress.yaml, thêm đoạn chú thích bên dưới. Thay thế \u0026lt;REPLACE-WITH-YOUR-CERTIFICATE-ARN\u0026gt; với Arn của chứng chỉ đã tạo và lưu lại.  ## SSL Settings\ralb.ingress.kubernetes.io/listen-ports: \u0026#39;[{\u0026#34;HTTPS\u0026#34;:443}, {\u0026#34;HTTP\u0026#34;:80}]\u0026#39;\ralb.ingress.kubernetes.io/certificate-arn: \u0026lt;REPLACE-WITH-YOUR-CERTIFICATE-ARN\u0026gt; Triển khai tài nguyên  Triển khai tài nguyên lên Namespace fcj-external-dns-ingress-ns.  kubectl apply -f ingress/externaldns/ssl-and-ssl-redirect -n fcj-external-dns-ingress-ns\rkubectl get all -n fcj-external-dns-ingress-ns Đi đến Load Balancer để xác minh có một Application Load Balancer vừa được tạo.  Nhấn vào nó và xác minh rằng có một Listener mới được tạo cho phương thức HTTPS trên cổng 443, và Default SSL/TLS certificate là chứng chỉ đã tạo ở bước trên.  Nhấn vào để xác minh Listener rules.    Với lưu lượng HTTPS đến cổng 443 với HTTP Host Header là firstcloudjourney-app1.\u0026lt;YOUR-DOMAIN-NAME\u0026gt;, nó sẽ chuyển đến Target Group của App1. Với lưu lượng HTTPS đến cổng 443 với HTTP Host Header là firstcloudjourney-app2.\u0026lt;YOUR-DOMAIN-NAME\u0026gt;, nó sẽ chuyển đến Target Group của App2.  Kiểm tra kết quả.  Truy cập http://firstcloudjourney-app1.\u0026lt;YOUR-DNS-NAME\u0026gt;/app1.   Chúng ta có thể kết nối tới ứng dụng App1 nhưng kết nối không được bảo mật.\nTruy cập https://firstcloudjourney-app1.\u0026lt;YOUR-DNS-NAME\u0026gt;/app1.   Với phương thức HTTPS, kết nối tới ứng dụng App1 được bảo mật.\nTương tự, truy cập http://firstcloudjourney-app2.\u0026lt;YOUR-DNS-NAME\u0026gt;/app2 và https://firstcloudjourney-app2.\u0026lt;YOUR-DNS-NAME\u0026gt;/app2 để kiểm tra kết quả.  Chuyển định tuyến lưu lượng truy cập HTTP đến cổng HTTPS. Chỉnh sửa tệp Manifest.  Mở tệp 05-ALB-ingress.yaml, thêm đoạn chú thích bên dưới. Sau đó lưu lại.  # SSL Redirect Setting\ralb.ingress.kubernetes.io/ssl-redirect: \u0026#39;443\u0026#39; Triển khai lại tài nguyên.  Triển khai lại tài nguyên trên Namespace fcj-external-dns-ingress-ns.  kubectl apply -f ingress/externaldns/ssl-and-ssl-redirect -n fcj-external-dns-ingress-ns\rkubectl get all -n fcj-external-dns-ingress-ns Chỉ có Ingress được cấu hình. Truy cập Application Load Balancer trên Load Balancer lần nữa để kiểm tra sự thay đổi.   Sự thay đổi xuất hiện trên HTTP:80, Rules giảm từ 3 xuống 1.\nNhấn HTTP:80 để kiểm tra sự thay đổi.   Tất cả Listener Rules đã bị xóa, có một quy tắc mới được tạo sẽ chuyển hướng đến Port 443 khi có lưu lượng yêu cầu.\nKiểm tra kết quả.  Truy cập http://firstcloudjourney-app1.\u0026lt;YOUR-DNS-NAME\u0026gt;/app1.   Lưu lượng truy cập sẽ được tự động chuyển hướng đến Port 443 với HTTPS protocol.\nTruy cập https://firstcloudjourney-app1.\u0026lt;YOUR-DNS-NAME\u0026gt;/app1.   Lưu lượng truy cập đến Port 443 với HTTPS protocol vẫn có thể được truy cập như bình thường.\nTương tự, tuy cập http://firstcloudjourney-app2.\u0026lt;YOUR-DNS-NAME\u0026gt;/app2 và https://firstcloudjourney-app2.\u0026lt;YOUR-DNS-NAME\u0026gt;/app2 để kiểm tra kết quả.   Dọn dẹp.  Xóa tất cả tài nguyên đã tạo  kubectl delete -f ingress/externaldns/ssl-and-ssl-redirect -n fcj-external-dns-ingress-ns\rkubectl get all -n fcj-external-dns-ingress-ns Sẽ giữ lại các tài nguyên liên quan đến dịch vụ external-dns và SSL certificate trên AWS Certificate Manager cho các phần tiếp theo.\n"
},
{
	"uri": "/vi/2-prerequiste/2.4-createekscluster/",
	"title": "Tạo Amazon EKS Cluster",
	"tags": [],
	"description": "",
	"content": "Ở bước trước đó, chúng ta đã cài đặt các công cụ cần thiết: awscli, kubectl và eksctl. Bây giờ chúng ta sẽ tạo một Amazon EKS Cluster với managed Node Group là EC2 Instance.\nTạo Amazon EKS Cluster.  Tại cửa sổ lệnh Cloud9, thực hiện câu lệnh này để tạo một Amazon EKS Cluster.  eksctl create cluster --name=fcj-elb-cluster --region=ap-southeast-1 --zones=ap-southeast-1a,ap-southeast-1b --without-nodegroup Sau đó, kiểm tra Cluster bằng câu lệnh.  eksctl get cluster --region=ap-southeast-1 Cho phép kubectl giao tiếp với cluster của bạn bằng việc thêm chuỗi này vào tệp kubectl config.  aws eks update-kubeconfig --region=ap-southeast-1 --name=fcj-elb-cluster Sau đó, xác nhận giao tiếp với cluster của bạn bằng câu lệnh.  kubectl get svc Chú ý: Kết quả mong đợi là sự xuất hiện của dịch vụ ClusterIP\nTạo và liên kết IAM OIDC Provider cho EKS Cluster. IAM OpenID Connect (OIDC) Provider giúp sử dụng một số tiện ích của Amazon EKS, hoặc cho phép khối lượng công việc riêng lẻ Kubernetes có các quyền AWS Identity and Access Management (IAM) cụ thể.\n Tại cửa sổ lệnh Cloud9, thực hiện câu lệnh này để tạo và liên kết một OIDC Provider tới Amazon EKS Cluster.  eksctl utils associate-iam-oidc-provider --cluster=fcj-elb-cluster --region=ap-southeast-1 --approve Để xác nhận OIDC Provider đã tạo, đi đến IAM. Chuyển đến mục Identity providers. Bạn sẽ thấy có một Provider được tạo  Tạo Amazon EKS managed Node Group.  Tại cửa sổ lệnh Cloud9, thực hiện câu lệnh này để tạo managed Node Group và liên kết nó tới EKS Cluster.  eksctl create nodegroup --name=fcj-elb-nodegroup --cluster=fcj-elb-cluster --region=ap-southeast-1 --node-type=t3.medium --nodes=1 --node-private-networking  Sẽ mất khoảng 15 phút để hoàn thành quy trình này.   Liệt kê tất cả các node trong cluster.\n  kubectl get nodes "
},
{
	"uri": "/vi/5-dnsingresswitheks/",
	"title": "(Tùy chọn) Tích hợp dịch vụ ExternalDNS cho Amazon EKS Cluster",
	"tags": [],
	"description": "",
	"content": "Tổng quan Ở phần này, chúng ta sẽ khám phá làm thế nào để tích hợp ExternalDNS Service (Route53 và AWS Certificate Manager) trên Amazon EKS Cluster. Đây là một phần tự chọn, bởi vì nó yêu cầu bạn cần có một Host Zone được kết nối bên trong Route53, Nếu bạn vẫn chưa có, bạn có thể mua một tên miền và thêm nó vào Hos Zone hoặc chỉ cần xem qua chương này để có cái nhìn tổng quan.\nNội dung  5.1 Triển khai ExternalDNS Service 5.2 Sử dụng ExternalDNS như Ingress Service 5.3 Name Based Virtual Host Routing 5.4 SSL và SSL Redirect 5.5 Target Type IP  "
},
{
	"uri": "/vi/5-dnsingresswitheks/5.5-targettypeip/",
	"title": "Target Type IP",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ triển khai ứng dụng trên Fargate Node với Ingress và ExternalDNS Service.\nTạo tệp Manifest.  Tạo thư mục mới cho phần này.  mkdir ingress/externaldns/target-type-ip\rls ingress/externaldns Tạo thư mục farget-profile để lưu tệp định nghĩa fargate profile.  mkdir ingress/externaldns/target-type-ip/farget-profile\rls ingress/externaldns/target-type-ip Tạo fargate-profile.yaml bên trong ingress/externaldns/target-type-ip/farget-profile.  touch ingress/externaldns/target-type-ip/farget-profile/fargate-profile.yaml\rls ingress/externaldns/target-type-ip/farget-profile/ Mở tệp fargate-profile.yaml và dán đoạn code bên dưới. Sau đó lưu lại.  apiVersion: eksctl.io/v1alpha5\rkind: ClusterConfig\rmetadata:\rname: fcj-elb-cluster\rregion: ap-southeast-1\rfargateProfiles:\r- name: fcj-fp\rselectors:\r- namespace: fcj-external-dns-ingress-ns\rlabels:\rrunon: fargate Tạo thư mục mới để chứa tệp manifest triển khai ứng dụng.  mkdir ingress/externaldns/target-type-ip/application\rls ingress/externaldns/target-type-ip Tạo tệp tên 01-App1-Deployment.yaml bên trong ingress/externaldns/target-type-ip/application.  touch ingress/externaldns/target-type-ip/application/01-App1-Deployment.yaml\rls ingress/externaldns/target-type-ip/application Mở tệp 01-App1-Deployment.yaml và dán đoạn code bên dưới. Sau đó lưu lại.  apiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: fcj-app1-deployment\rlabels:\rapp: fcj-app1\rrunon: fargate\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: fcj-app1\rtemplate:\rmetadata:\rlabels:\rapp: fcj-app1\rrunon: fargate spec:\rcontainers:\r- name: fcj-app1\rimage: stacksimplify/kube-nginxapp1:1.0.0\rports:\r- containerPort: 80 Tạo tệp tên 02-App1-ClusterIP.yaml bên trong ingress/externaldns/target-type-ip/application.  touch ingress/externaldns/target-type-ip/application/02-App1-ClusterIP.yaml\rls ingress/externaldns/target-type-ip/application Mở tệp 02-App1-ClusterIP.yaml và dán đoạn code bên dưới. Sau đó lưu lại.  apiVersion: v1\rkind: Service\rmetadata:\rname: fcj-app1-clusterip-service\rlabels:\rapp: fcj-app1\rrunon: fargate\rannotations:\ralb.ingress.kubernetes.io/healthcheck-path: /app1/index.html\rspec:\rtype: ClusterIP\rselector:\rapp: fcj-app1\rports:\r- port: 80\rtargetPort: 80 Tương tự, tạo tệp tên 03-App2-Deployment.yaml và dán đoạn code bên dưới. Sau đó lưu lại.  apiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: fcj-app2-deployment\rlabels:\rapp: fcj-app2\rrunon: fargate\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: fcj-app2\rtemplate:\rmetadata:\rlabels:\rapp: fcj-app2\rrunon: fargate\rspec:\rcontainers:\r- name: fcj-app2\rimage: stacksimplify/kube-nginxapp2:1.0.0\rports:\r- containerPort: 80 Tương tự, tạo tệp tên 04-App2-ClusterIP.yaml và dán đoạn code bên dưới. Sau đó lưu lại.  apiVersion: v1\rkind: Service\rmetadata:\rname: fcj-app2-clusterip-service\rlabels:\rapp: fcj-app2\rrunon: fargate\rannotations:\ralb.ingress.kubernetes.io/healthcheck-path: /app2/index.html\rspec:\rtype: ClusterIP\rselector:\rapp: fcj-app2\rports:\r- port: 80\rtargetPort: 80 Tương tự, tạo tệp tên 05-ALB-ingress.yaml, dán đoạn code bên dưới và thay thế \u0026lt;REPLACE-WITH-YOUR-HOST-HEADER-APP1\u0026gt; và \u0026lt;REPLACE-WITH-YOUR-HOST-HEADER-APP2\u0026gt; với Host Header . Sau đó lưu lại.  apiVersion: networking.k8s.io/v1\rkind: Ingress\rmetadata:\rname: fcj-target-type-ip-ingress\rlabels:\rrunon: fargate\rannotations:\r# Load Balancer Name\ralb.ingress.kubernetes.io/load-balancer-name: fcj-target-type-ip\r# Ingress Core Settings\ralb.ingress.kubernetes.io/scheme: internet-facing\r# Health Check Settings\ralb.ingress.kubernetes.io/healthcheck-protocol: HTTP alb.ingress.kubernetes.io/healthcheck-port: traffic-port\ralb.ingress.kubernetes.io/healthcheck-interval-seconds: \u0026#39;15\u0026#39;\ralb.ingress.kubernetes.io/healthcheck-timeout-seconds: \u0026#39;5\u0026#39;\ralb.ingress.kubernetes.io/success-codes: \u0026#39;200\u0026#39;\ralb.ingress.kubernetes.io/healthy-threshold-count: \u0026#39;2\u0026#39;\ralb.ingress.kubernetes.io/unhealthy-threshold-count: \u0026#39;2\u0026#39;\r## SSL Settings\ralb.ingress.kubernetes.io/listen-ports: \u0026#39;[{\u0026#34;HTTPS\u0026#34;:443}, {\u0026#34;HTTP\u0026#34;:80}]\u0026#39;\ralb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:ap-southeast-1:170074558790:certificate/3798d174-1dc8-4380-974b-c219a4317730\r# SSL Redirect Setting\ralb.ingress.kubernetes.io/ssl-redirect: \u0026#39;443\u0026#39; # For Fargate\ralb.ingress.kubernetes.io/target-type: ip spec:\ringressClassName: my-aws-ingress-class # Ingress Class\rrules:\r- host: \u0026lt;REPLACE-WITH-YOUR-HOST-HEADER-APP1\u0026gt;\rhttp:\rpaths:\r- path: /\rpathType: Prefix\rbackend:\rservice:\rname: fcj-app1-clusterip-service\rport:\rnumber: 80\r- host: \u0026lt;REPLACE-WITH-YOUR-HOST-HEADER-APP2\u0026gt;\rhttp:\rpaths:\r- path: /\rpathType: Prefix\rbackend:\rservice:\rname: fcj-app2-clusterip-service\rport:\rnumber: 80 Triển khai tài nguyên. Tạp Fargate Profile  Tạo Fargate Profile trong EKS Cluster.  eksctl create fargateprofile -f ingress/externaldns/target-type-ip/farget-profile/fargate-profile.yaml Liệt kê Fargate Profile trong EKS Cluster.  eksctl get fargateprofile --cluster fcj-elb-cluster --region ap-southeast-1 Triển khai tài nguyên.  Triển khai tài nguyên trên Namespace fcj-external-dns-ingress-ns.  kubectl apply -f ingress/externaldns/target-type-ip/application -n fcj-external-dns-ingress-ns Liệt kê các tài nguyên đã tạo.  kubectl get all -n fcj-external-dns-ingress-ns Liệt kê tất cả Node trong Cluster.  kubectl get node -o wide Có 2 máy chủ Fargate cho ứng dụng App1 và App2.\nKiểm tra kết quả.   Truy cập http://firstcloudjourney-app1.\u0026lt;YOUR-DNS-NAME\u0026gt;/app1.   Truy cập http://firstcloudjourney-app2.\u0026lt;YOUR-DNS-NAME\u0026gt;/app2.   Dọn dẹp  Xóa các tài nguyên đã tạo.  kubectl delete -f ingress/externaldns/target-type-ip/application -n fcj-external-dns-ingress-ns\rkubectl get all -n fcj-external-dns-ingress-ns Sẽ giữ lại các tài nguyên liên quan đến dịch vụ external-dns và SSL certificate trên AWS Certificate Manager cho các phần tiếp theo.\nLiệt kê các Node hiện tại trong Cluster để xác minh hai Fargate Node được tạo đã bị xóa thành công.  kubectl get node -o wide "
},
{
	"uri": "/vi/2-prerequiste/2.5-createapplication/",
	"title": "Tạo ứng dụng",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ tạo một ứng dụng đơn giản với 2 phiên bản v1 và v2. Sau đó, docker hóa và đẩy chúng lên DockerHub cho EKS Cluster sử dụng.\nTạo ứng dụng v1  Tại cửa sổ lệnh Cloud9, nhập câu lệnh bên dưới để tạo một thư mục mới cho ứng dụng.  mkdir app\rcd app Khởi tạo ứng dụng.  npm init Nhấn Enter để bỏ qua các bước này và xác nhận Yes để hoàn tất.  Tạo một tệp tên index.js.  touch index.js Mở tệp index.js và thực hiện mã code.  import express from \u0026#39;express\u0026#39;  const app = express()  app.get(\u0026#39;/\u0026#39;,(req, res) =\u0026gt; {  res.json(\u0026#34;Hello world from FCJ Workshop V1!\u0026#34;) })  app.listen(8080, ()=\u0026gt; {  console.log(\u0026#34;application running on 8080\u0026#34;) }) Tại cửa sổ lệnh Cloud9, cài đặt express framework.  npm i express Lưu tệp và khởi chạy ứng dụng.  node index.js  Nhưng chúng ta sẽ gặp mã lỗi như bên dưới.   Để sửa lỗi này, mở tệp package.json và thêm đoạn định nghĩa này. Sau đó lưu lại.\n  \u0026#34;type\u0026#34;:\u0026#34;module\u0026#34;, Bây giờ, hãy chạy lại ứng dụng.  node index.js Ứng dụng đã khởi chạy trên port 8080.   Bây giờ, chúng ta sẽ truy cập vào ứng dụng để kiểm tra kết quả.\n Nhấn Share.\n  Sao chép IP Address tại Application.   Truy cập vào ứng dụng với đường dẫn http://\u0026lt;REPLACE_YOUR_IP\u0026gt;:8080.\n  Nhưng ứng dụng không thể truy cập được.   Nguyên nhân là bởi vì Security group của máy chủ làm việc vẫn chưa mở Port 8080.\n Nhấn vào biểu tượng R và chọn Manage EC2 Instance để đi đến máy chủ làm việc.   Tại trang Instances, chọn máy chủ làm việc của bạn.\n  Chuyển đến thanh Security.\n  Nhấn Security Group.   Tại trang Inbound rules, bạn có thể thấy chưa có quy tắc nào được định nghĩa.\nNhấn Edit inbound rules.  Tại trang Edit inbound rules, nhấn Add rule.  Định nghĩa quy tắc với thông số:   Type là Custom TCP. Port range là 8080. Source là Anywhere-IPv4.   Sau đó, nhấn Save rules.   Bây giờ, hãy truy cập lại ứng dụng để kiểm tra kết quả.   Docker hóa ứng dụng v1  Tạo tệp tên Dockerfile.  touch Dockerfile  Mở Dockerfile.   Nhập đoạn code bên dưới.\n  FROMnode:13-alpine#configure working directoryWORKDIR/appCOPY package.json ./RUN npm install#bundle the source codeCOPY . ./EXPOSE8080CMD [\u0026#34;node\u0026#34;,\u0026#34;index.js\u0026#34;]Chú ý:\n  Tại bước COPY package.json ./, Docker sẽ sao chép tệp package.json tới thư mục /app, sau đó thực hiện RUN npm install để cài đặt tất cả các gói hổ trợ được định nghĩa trong tệp package.json và lưu chúng vào thư mục node_modules.\n  Tại bước COPY . ./, Docker sẽ sao chép tất cả tài nguyên trên máy chủ làm việc đến thư mục /app - bao gồm thư mục node_modules và tệp Dockerfile. Các tệp và thư mục này không cần thiết để sao chép lại lên thư mục làm việc. Vì thể chúng ta có thể tạo .dockerignore để liệt kê các thư mục và tệp nào không cần sao chép vào thư mục làm việc.\n  Tạo tệp tên .dockerignore bằng câu lệnh.  touch .dockerignore Bạn sẽ không thấy .dockerignore ở đâu, vì Cloud9 nhận định .dockerignore là tệp ẩn.\nNhấn Setting. Chọn Show Hidden Files.  Mở .dockerignore và nhập các giá trị bên dưới.  node_modules\rDockerfile Chạy câu lệnh này để liệt kê tất cả Image đang tồn tại bên trong máy chủ làm việc của bạn.  docker images Không có Image nào tồn tại. 9. Hãy xây dụng container image.\ndocker build -t fcj-application:v1 . Liệt kê Image lại lần nữa.  docker images Container image đã được xây dựng với nhãn v1 thành công.\nTạo ứng dụng v2   Mở tệp index.js và thay thế res.json(\u0026ldquo;Hello world from FCJ Workshop V1!\u0026rdquo;) thành res.json(\u0026ldquo;Hello world from FCJ Workshop V2!\u0026rdquo;) ở dòng 6.   Khởi chạy ứng dụng để kiểm tra kết quả.   Truy cập vào đường dẫn của ứng dụng.   Docker hóa ứng dụng v2  Hãy xây dụng Container image.  docker build -t fcj-application:v2 . Liệt kê Image lần nữa.  docker images Đẩy container image lên DockerHub.   Truy cập và đăng nhập vào DockerHub với tài khoản của bạn.\n  Tạo một Repository cho bài thực hành này.   Nhập các thông tin được yêu cầu:\n   Name: fcj-elbeks-workshop-basicapp. Description: Store container image for Amazon ELB with Amazon EKS Cluster Workshop. Sau đó nhấn Create.   Kế tiếp, chúng ta sẽ tạo một Access Token được sử dụng để đăng nhập vào DockerHub từ máy chủ làm việc.\n Nhấn avatar của bạn (Góc trên phải của trang).\n  Nhấn My Account.\n  Nhấn Security.\n  Cuối cùng, nhấn New Access Token.   Điền Access Token Description.\n  Nhấn Generate.   Lưu trữ Access token được tạo ra.   Trở lại cửa sổ lệnh của Cloud9. Nhập câu lệnh bên dưới để đăng nhập và cung cấp Access Token khi được yêu cầu.\n  docker login -u \u0026lt;REPLACE-YOUR-DOCKERHUB-USERNAME\u0026gt; Để đẩy container image lên repository, Repository của container image phải khớp với định dạng repository của DockerHub \u0026lt;YOUR_USER_NAME\u0026gt;/\u0026lt;YOUR_REPOSITORY_NAME\u0026gt;. Vì thế bây giờ chúng ta cần sử dụng docker image tag command để sao chép và chuẩn hóa định dạng repository của container image trong máy chủ làm việc.\nThực hiện câu lệnh này để dán nhãn cho container image phiên bản v1 và v2.  docker image tag fcj-application:v1 firstcloudjourneypcr/fcj-elbeks-workshop-basicapp:v1\rdocker image tag fcj-application:v2 firstcloudjourneypcr/fcj-elbeks-workshop-basicapp:v2 Liệt kê tất cả image.  docker images Bây giờ, có 2 ontainer image mới là firstcloudjourneypcr/fcj-elbeks-workshop-basicapp với nhãn là v1 và firstcloudjourneypcr/fcj-elbeks-workshop-basicapp với nhãn là v2. Kế tiếp, hãy đẩy các container image này lên DockerHub.\nThực thi câu lệnh này để đẩy container image cả phiên bản v1 và v2 lên DockerHub.  docker push firstcloudjourneypcr/fcj-elbeks-workshop-basicapp:v1\rdocker push firstcloudjourneypcr/fcj-elbeks-workshop-basicapp:v2 Trở về Docker Hub Repository để kiểm tra kết quả. Có 2 container image vừa được đẩy lên.  "
},
{
	"uri": "/vi/6-nlbwitheks/",
	"title": "Dịch vụ Network Load Balancer với Amazon EKS Cluster",
	"tags": [],
	"description": "",
	"content": "Tổng quan Trong phần này, chúng ta sẽ khám phá cách làm thế nào để triển khau ứng dụng trên Network Load Balancer và tích hợp ExternalDNS Service (Route53 và AWS Certificate Manager) lên Amazon EKS Cluster.\nNội dung  6.1 Dịch vụ Network Load Balancer với Amazon EKS Cluster EC2 Managed Node 6.2 Dịch vụ Network Load Balancer với Amazon EKS Cluster Fargate Node  "
},
{
	"uri": "/vi/7-cleanup/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "Xóa Amazon EKS Cluster.  Tại cửa sổ lệnh Cloud9, thực thi câu lệnh bên dưới để xóa EKS Cluster.  eksctl delete cluster --name fcj-elb-cluster --region ap-southeast-1 Sẽ mất khoảng 15 phút để hoàn tất.  Xóa chứng chỉ AWS Certificate Manager.   Đi đến AWS Certificate Manager certificate., chọn chứng chỉ mà bạn đã tạo.\n  Nhấn Delete.   Nhập delete để xác nhận.\n  Sau đó, nhấn Delete để xóa.   Xóa Route 53 Record đã tạo.   Đi đến Host Zone của bạn trên Route 53.\n  Chọn bản ghi được tạo bởi AWS Certificate Manager.\n  Nhấn Delete record.   Sau đó, nhấn Delete để xóa.\n  Xóa Cloud9 Workspace.  Đi đến Cloud9. Chọn FCJ-Workspace. Nhấn Delete.  Nhập Delete để xác nhận. Nhấn Delete.   "
},
{
	"uri": "/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]